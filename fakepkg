#!/bin/bash

# Actual assembly function
# $1: pkgname , $2: destination dir , $3 verbosity
function fakebuild() {
    # Setting global vars
    PKG_NAME="$1-$(pacman -Qi $1 | sed -n 2p | awk '{print $3}')"
    PKG_DB_ENTRY="/var/lib/pacman/local/$PKG_NAME"
    PKG_EXT=".pkg.tar.xz"   # This does not define the compression format

    # Skipping if the package already exists in the destination dir
    if [[ -f $2/${PKG_NAME}${PKG_EXT} ]]; then
        echo -e "\e[39;1m${PKG_NAME}${PKG_EXT}\e[0m already exists in $2! Skipping..."
        return -2
    fi

    # Create and enter a temporaray dir
    TMPDIR=$(mktemp -q -p /tmp -t -d fakepackage.XXX)
    cd $TMPDIR

    # Fetching the .PKGINFO, .Changelog, .MTREE and .INSTALL file
    [[ -f $PKG_DB_ENTRY/desc ]] && cp -a $PKG_DB_ENTRY/desc PRE_PKGINFO || (echo -e "Could not find a databse entry for \e[39;1m$PKG_NAME\e[0m" && return -1)
    [[ -f $PKG_DB_ENTRY/install ]] && cp -a $PKG_DB_ENTRY/install .INSTALL
    [[ -f $PKG_DB_ENTRY/mtree ]] && gzip -dc $PKG_DB_ENTRY/mtree > .MTREE
    [[ -f $PKG_DB_ENTRY/changelog ]] && cp -a $PKG_DB_ENTRY/changelog .Changelog

    # Hacking together the .PKGINFO
    sed -n -e '/%BACKUP%/,$p' $PKG_DB_ENTRY/files  | awk '{print $1}' > .PKGINFO
    sed -i '/^$/d' PRE_PKGINFO
    while read line; do
        if [[ $line =~ %[A-Z]+% ]]; then
            PKG_VAR=$(echo ${line,,} | tr -d '%')
            case "$PKG_VAR" in
                "name")     PKG_VAR=pkgname;;
                "version")  PKG_VAR=pkgver;;
                "desc")     PKG_VAR=pkgdesc;;
                "groups")   PKG_VAR=group;;
                "depends")  PKG_VAR=depend;;
                "optdepends")   PKG_VAR=optdepend;;
                "conflicts")    PKG_VAR=conflict;;
            esac
        else
            echo -e "$PKG_VAR = $line" >> .PKGINFO
        fi
    done < PRE_PKGINFO
    sed -i '/installdate/d' .PKGINFO
    sed -i '/validation/d' .PKGINFO
    rm PRE_PKGINFO

    # Assembling a list of all files belonging to the package
    PACFILES=$(pacman -Qlq $1)
    PACFILES="$PACFILES .PKGINFO"
    [[ -f .INSTALL ]] && PACFILES="$PACFILES .INSTALL"
    [[ -f .Changelog ]] && PACFILES="$PACFILES .Changelog"
    [[ -f .MTREE ]] && PACFILES="$PACFILES .MTREE"

    # Taring things together
    if [[ $3 -ge "1" ]]; then
        #XZ_OPT="-T 0" \
        tar --ignore-failed-read --owner=0 --group=0 --no-recursion -cJf ${PKG_NAME}${PKG_EXT} $PACFILES
    else
        #XZ_OPT="-T 0" \
        tar --ignore-failed-read --owner=0 --group=0 --no-recursion -cJf ${PKG_NAME}${PKG_EXT} $PACFILES 2>&1 >/dev/null | grep -i "permission denied" >/dev/null
        [[ $? -eq 0 ]] && echo -e "The permission to open one or more directories was denied for \e[39;1m$PKG_NAME\e[0m. The package may be incomplete!"
    fi

    # Cleanup
    if [[ -f ${PKG_NAME}${PKG_EXT} ]]; then
        mv ${PKG_NAME}${PKG_EXT} $2
    else
        echo "Internal error occured while processing $PKG_NAME!"
    fi
    rm -rf $TMPDIR
    echo -e "Reassembled \e[39;1m$PKG_NAME\e[0m successfully!"
}
export -f fakebuild

# Help function, no arguments required
function help() {
    cat << 'EOF'
fakepkg 1.21.5
This script was design to reassemble installed packages from its deliverd files.
It comes in handy if there is no internet connection available and you have no
access to an up-to-date package cache.

Usage: fakepkg [-v] [-j <jobs>] [-o <dir>] <package(s)>
    -h, --help              Display this help message and exit
    -v, --verbose           Increase verbosity
    -j, --jobs <jobs>       Build in parallel - you may want to set XZ_OPT
    -o, --out  <dir>        Write output to <dir>

Examples:   # fakepkg slurm-llnl
            # fakepkg gzip munge binutils -o ~/Downloads
            # fakepkg -o /tmp -p 5 gzip munge binutils
            # fakepkg $(pacman -Qsq)

Copyright (c) Gordian Edenhofer <gordian.edenhofer@gmail.com>
The script requires bash>=4.2, pacman, tar, xz, gzip and parallel.
EOF
}

# Show help and quit if invoced
[[ $# -eq 0 ]] && help && exit -1
for ARG in "$@"; do
    [[ $ARG == "-h" || $ARG == "--help" ]] && help && exit 0
done

# Assembling PKG_LIST and DEST_DIR
PARAMS=$(getopt -o o:j:v --long out:,jobs:,verbose -n "fakepkg" -- "$@")
[[ $? -ne 0 ]] && echo "Try 'fakepkg --help' for more information." && exit -2
eval set -- "$PARAMS"
DEST_DIR=$PWD   # Default value
PARALLEL=-1     # Default value
VERBOSITY=0       # Default value
while true ; do
    case "$1" in
        -o|--out)
            DEST_DIR="$(readlink -e $2)"
            [[ $? -ne 0 ]] && echo -e "The directory \e[39;1m$2\e[0m does not exist!" && exit -3
            shift
            ;;
        -j|--jobs)
            if [[ $2 =~ ^-?[0-9]+$ ]]; then
                PARALLEL=$2
            else
                echo -e "\e[39;1m$2\e[0m is not a valid integer!"
                exit -1
            fi
            shift
            ;;
        -v|--verbose)
            VERBOSITY=$((VERBOSITY+1))
            ;;
        --)
            shift
            break
            ;;
        *)
            help
            exit -4
            ;;
    esac
    shift
done
PKG_LIST=($*)

# Checking the PKG_LIST
[[ ${#PKG_LIST[@]} == 0 ]] && help && exit -1
if [[ $(pacman -T ${PKG_LIST[@]} 2>&1 >/dev/null; echo $?) -ne 0 ]]; then
    echo -e "The following package(s) could not be found on your system: \e[39;1m$(pacman -T ${PKG_LIST[@]} | tr '\n' ' ')\e[0m"
    echo -e "Keep in mind that the package(s) have to be installed!"
    exit -127
fi

# Assembling the packages
if [[ $PARALLEL -gt "1" ]]; then
    parallel --will-cite -j $PARALLEL fakebuild ::: "${PKG_LIST[@]}" ::: "$DEST_DIR" ::: "$VERBOSITY"
else
    for PKG in ${PKG_LIST[@]}; do fakebuild $PKG "$DEST_DIR" "$VERBOSITY"; done
fi
